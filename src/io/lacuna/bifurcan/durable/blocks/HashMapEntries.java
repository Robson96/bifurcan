package io.lacuna.bifurcan.durable.blocks;

import io.lacuna.bifurcan.*;
import io.lacuna.bifurcan.durable.BlockPrefix.BlockType;
import io.lacuna.bifurcan.durable.DurableAccumulator;
import io.lacuna.bifurcan.durable.Util;
import io.lacuna.bifurcan.utils.Iterators;

import java.util.Iterator;
import java.util.PrimitiveIterator;
import java.util.function.BiPredicate;

/**
 * A block that represents zero or more key/value pairs in a HashMap.
 *
 * Encoding:
 * - the number of preceding entries [VLQ]
 * - the hash for each entry [HashDeltas]
 * - keys [an ENCODED block generated by {@code DurableEncoding.keyEncoding()}]
 * - values [an ENCODED block generated by {@code DurableEncoding.valueEncoding(firstKey)}
 */
public class HashMapEntries {

  private static final BlockType BLOCK_TYPE = BlockType.OTHER;

  public static <K, V> void encode(
      long offset,
      Util.Block<HashMap.MapEntry<K, V>, DurableEncoding> block,
      DurableEncoding keyEncoding,
      DurableOutput out) {
    DurableAccumulator.flushTo(out, BLOCK_TYPE, acc -> {
      acc.writeVLQ(offset);

      HashDeltas.Writer hashes = new HashDeltas.Writer();
      block.elements.forEach(e -> hashes.append(e.hash));
      hashes.flushTo(acc);

      Util.encodeBlock(Lists.lazyMap(block.elements, e -> e.key), keyEncoding, acc);
      Util.encodeBlock(Lists.lazyMap(block.elements, e -> e.value), block.encoding, acc);
    });
  }

  public static HashMapEntries decode(DurableInput in, DurableEncoding mapEncoding) {
    DurableInput entries = in.sliceBlock(BLOCK_TYPE);
    long entryOffset = entries.readVLQ();
    HashDeltas deltas = HashDeltas.decode(entries);
    DurableInput keys = entries.slicePrefixedBlock();
    DurableInput values = entries.slicePrefixedBlock();

    return new HashMapEntries(entryOffset, deltas, keys, values, mapEncoding);
  }

  public static Object get(Iterator<HashMapEntries> it, int hash, Object key, Object defaultValue) {
    while (it.hasNext()) {
      HashMapEntries entries = it.next();
      HashDeltas.IndexRange candidates = entries.hashes.candidateIndices(hash);
      if (candidates.start == -1) {
        return defaultValue;
      }

      int keyIndex = entries.localIndexOf(candidates, key);
      if (keyIndex == -1 && candidates.isBounded) {
        return defaultValue;
      } else if (keyIndex != -1) {
        return Util.decodeBlock(entries.values, entries.mapEncoding.valueEncoding(key)).skip(keyIndex).next();
      }
    }
    return defaultValue;
  }

  public static long indexOf(Iterator<HashMapEntries> it, int hash, Object key) {
    while (it.hasNext()) {
      HashMapEntries entries = it.next();
      HashDeltas.IndexRange candidates = entries.hashes.candidateIndices(hash);
      if (candidates.start == -1) {
        return -1;
      }

      int keyIndex = entries.localIndexOf(candidates, key);
      if (keyIndex == -1 && candidates.isBounded) {
        return -1;
      } else if (keyIndex != -1) {
        return entries.entryOffset + keyIndex;
      }
    }

    return -1;
  }


  public final long entryOffset;
  public final HashDeltas hashes;
  public final DurableInput keys, values;
  public final DurableEncoding mapEncoding;

  private HashMapEntries(
      long entryOffset,
      HashDeltas hashes,
      DurableInput keys,
      DurableInput values,
      DurableEncoding mapEncoding) {
    this.entryOffset = entryOffset;
    this.hashes = hashes;
    this.keys = keys;
    this.values = values;
    this.mapEncoding = mapEncoding;
  }

  private int localIndexOf(HashDeltas.IndexRange candidates, Object key) {
    assert (candidates.start != -1);

    DurableEncoding.SkippableIterator it = Util.decodeBlock(keys, mapEncoding.keyEncoding()).skip(candidates.start);
    BiPredicate<Object, Object> keyEquals = mapEncoding.keyEquality();

    for (int i = candidates.start; i < candidates.end; i++) {
      Object k = it.next();
      if (keyEquals.test(k, key)) {
        return i;
      }
    }

    return -1;
  }

  public IEntry<Object, Object> nth(long index) {
    Object key = Util.decodeBlock(keys, mapEncoding.keyEncoding()).skip(index).next();
    Object value = Util.decodeBlock(values, mapEncoding.valueEncoding(key)).skip(index).next();

    return new Maps.Entry<>(key, value);
  }

  public Iterator<HashMap.MapEntry<Object, Object>> entries(long dropped) {
    PrimitiveIterator.OfInt hashes = (PrimitiveIterator.OfInt) Iterators.drop(this.hashes.iterator(), dropped);
    DurableEncoding.SkippableIterator keys = Util.decodeBlock(this.keys, mapEncoding.keyEncoding()).skip(dropped);
    Object firstKey = keys.next();
    DurableEncoding.SkippableIterator values = Util.decodeBlock(this.values, mapEncoding.valueEncoding(firstKey)).skip(dropped);

    return Iterators.concat(
        Iterators.singleton(new HashMap.MapEntry<>(hashes.next(), new Maps.Entry<>(firstKey, values.next()))),
        new Iterator<HashMap.MapEntry<Object, Object>>() {
          @Override
          public boolean hasNext() {
            return hashes.hasNext();
          }

          @Override
          public HashMap.MapEntry<Object, Object> next() {
            return new HashMap.MapEntry<>(hashes.next(), new Maps.Entry<>(keys.next(), values.next()));
          }
        });
  }
}
