package io.lacuna.bifurcan.durable.blocks;

import io.lacuna.bifurcan.*;
import io.lacuna.bifurcan.durable.BlockPrefix;
import io.lacuna.bifurcan.durable.BlockPrefix.BlockType;
import io.lacuna.bifurcan.durable.SwapBuffer;
import io.lacuna.bifurcan.durable.Util;

import java.util.Iterator;

/**
 * An indexed list, encoded as:
 * - the number of elements [VLQ]
 * - number of SkipTable tiers [uint8]
 * - a SkipTable over the blocks of elements (unless number of tiers is 0)
 * - zero or more ENCODED blocks generated by {@code DurableEncoding.elementEncoding(index)}
 */
public class List {

  public static <V> void encode(Iterator<V> it, IDurableEncoding.List listEncoding, DurableOutput out) {
    SkipTable.Writer skipTable = new SkipTable.Writer();
    SwapBuffer elements = new SwapBuffer();

    IDurableEncoding elementEncoding = listEncoding.elementEncoding();
    Iterator<IList<V>> blocks = Util.partitionBy(
        it,
        elementEncoding.blockSize(),
        elementEncoding::isSingleton);

    long index = 0;
    while (blocks.hasNext()) {
      IList<V> b = blocks.next();
      skipTable.append(index, elements.written());
      Util.encodeBlock((IList<Object>) b, elementEncoding, elements);
      index += b.size();
    }

    long size = index;
    SwapBuffer.flushTo(out, BlockType.LIST, acc -> {
      acc.writeVLQ(size);
      acc.writeUnsignedByte(skipTable.tiers());

      if (skipTable.tiers() > 0) {
        skipTable.flushTo(acc);
      } else {
        skipTable.free();
      }

      elements.flushTo(acc);
    });
  }

  public static DurableList decode(DurableInput in, IDurableCollection.Root root, IDurableEncoding.List encoding) {
    DurableInput bytes = in.duplicate();

    BlockPrefix prefix = in.readPrefix();
    assert (prefix.type == BlockType.LIST);
    long pos = in.position();

    long size = in.readVLQ();
    int skipTableTiers = in.readUnsignedByte();

    SkipTable skipTable = null;
    if (skipTableTiers > 0) {
      skipTable = new SkipTable(in.sliceBlock(BlockType.TABLE), skipTableTiers);
    }

    DurableInput elements = in.sliceBytes((pos + prefix.length) - in.position());

    return new DurableList(bytes, root, size, skipTable, elements, encoding);
  }


}
